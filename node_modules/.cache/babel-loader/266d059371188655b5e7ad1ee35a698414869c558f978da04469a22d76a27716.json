{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthPKCEGrantCodeExchangeError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthInvalidTokenResponseError, AuthUnknownError, isAuthApiError, isAuthError } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid, retryable, sleep, generatePKCEVerifier, generatePKCEChallenge, supportsLocalStorage } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n  flowType: 'implicit'\n};\n/** Current session will be checked for refresh at this interval. */\nconst AUTO_REFRESH_TICK_DURATION = 30 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\nconst AUTO_REFRESH_TICK_THRESHOLD = 3;\nexport default class GoTrueClient {\n  /**\n   * Create a new client for use in the browser.\n   */\n  constructor(options) {\n    var _a;\n    this.stateChangeEmitters = new Map();\n    this.autoRefreshTicker = null;\n    this.visibilityChangedCallback = null;\n    this.refreshingDeferred = null;\n    /**\n     * Keeps track of the async client initialization.\n     * When null or not yet resolved the auth state is `unknown`\n     * Once resolved the the auth state is known and it's save to call any further client methods.\n     * Keep extra care to never reject or throw uncaught errors\n     */\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    /**\n     * Used to broadcast state change events to other tabs listening.\n     */\n    this.broadcastChannel = null;\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || localStorageAdapter;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.flowType = settings.flowType;\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n    };\n    if (this.persistSession && this.storage === localStorageAdapter && !supportsLocalStorage()) {\n      console.warn(`No storage option exists to persist the session, which may result in unexpected behavior when using auth.\n        If you want to set persistSession to true, please provide a storage option or you may set persistSession to false to disable this warning.`);\n    }\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n      try {\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n      } catch (e) {\n        console.error('Failed to create a new BroadcastChannel, multi-tab state changes will not be available', e);\n      }\n      (_a = this.broadcastChannel) === null || _a === void 0 ? void 0 : _a.addEventListener('message', event => __awaiter(this, void 0, void 0, function* () {\n        yield this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n      }));\n    }\n\n    this.initialize();\n  }\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n  initialize() {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize();\n    }\n    return this.initializePromise;\n  }\n  /**\n   * IMPORTANT:\n   * 1. Never throw in this method, as it is called from the constructor\n   * 2. Never return a session from this method as it would be cached over\n   *    the whole lifetime of the client\n   */\n  _initialize() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.initializePromise) {\n        return this.initializePromise;\n      }\n      try {\n        const isPKCEFlow = isBrowser() ? yield this._isPKCEFlow() : false;\n        if (isPKCEFlow || this.detectSessionInUrl && this._isImplicitGrantFlow()) {\n          const {\n            data,\n            error\n          } = yield this._getSessionFromUrl(isPKCEFlow);\n          if (error) {\n            // failed login attempt via url,\n            // remove old session as in verifyOtp, signUp and signInWith*\n            yield this._removeSession();\n            return {\n              error\n            };\n          }\n          const {\n            session,\n            redirectType\n          } = data;\n          yield this._saveSession(session);\n          setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            if (redirectType === 'recovery') {\n              yield this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n            } else {\n              yield this._notifyAllSubscribers('SIGNED_IN', session);\n            }\n          }), 0);\n          return {\n            error: null\n          };\n        }\n        // no login attempt via callback url try to recover session from storage\n        yield this._recoverAndRefresh();\n        return {\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            error\n          };\n        }\n        return {\n          error: new AuthUnknownError('Unexpected error during initialization', error)\n        };\n      } finally {\n        yield this._handleVisibilityChange();\n      }\n    });\n  }\n  /**\n   * Creates a new user.\n   *\n   * Be aware that if a user account exists in the system you may get back an\n   * error message that attempts to hide this information from the user.\n   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  signUp(credentials) {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n        if ('email' in credentials) {\n          const {\n            email,\n            password,\n            options\n          } = credentials;\n          let codeChallenge = null;\n          let codeChallengeMethod = null;\n          if (this.flowType === 'pkce') {\n            const codeVerifier = generatePKCEVerifier();\n            yield setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);\n            codeChallenge = yield generatePKCEChallenge(codeVerifier);\n            codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n          }\n          res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n            headers: this.headers,\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n            body: {\n              email,\n              password,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              },\n              code_challenge: codeChallenge,\n              code_challenge_method: codeChallengeMethod\n            },\n            xform: _sessionResponse\n          });\n        } else if ('phone' in credentials) {\n          const {\n            phone,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n              channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : 'sms',\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n        }\n        const {\n          data,\n          error\n        } = res;\n        if (error || !data) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: error\n          };\n        }\n        const session = data.session;\n        const user = data.user;\n        if (data.session) {\n          yield this._saveSession(data.session);\n          yield this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n        return {\n          data: {\n            user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in an existing user with an email and password or phone and password.\n   *\n   * Be aware that you may get back an error message that will not distinguish\n   * between the cases where the account does not exist or that the\n   * email/phone and password combination is wrong or that the account can only\n   * be accessed via social login.\n   */\n  signInWithPassword(credentials) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n        if ('email' in credentials) {\n          const {\n            email,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              email,\n              password,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else if ('phone' in credentials) {\n          const {\n            phone,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n        }\n        const {\n          data,\n          error\n        } = res;\n        if (error) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        } else if (!data || !data.session || !data.user) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: new AuthInvalidTokenResponseError()\n          };\n        }\n        if (data.session) {\n          yield this._saveSession(data.session);\n          yield this._notifyAllSubscribers('SIGNED_IN', data.session);\n        }\n        return {\n          data: {\n            user: data.user,\n            session: data.session\n          },\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in an existing user via a third-party provider.\n   * This method supports the PKCE flow.\n   */\n  signInWithOAuth(credentials) {\n    var _a, _b, _c, _d;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._removeSession();\n      return yield this._handleProviderSignIn(credentials.provider, {\n        redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n        scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n        queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n        skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect\n      });\n    });\n  }\n  /**\n   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n   */\n  exchangeCodeForSession(authCode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const codeVerifier = yield getItemAsync(this.storage, `${this.storageKey}-code-verifier`);\n      const {\n        data,\n        error\n      } = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=pkce`, {\n        headers: this.headers,\n        body: {\n          auth_code: authCode,\n          code_verifier: codeVerifier\n        },\n        xform: _sessionResponse\n      });\n      yield removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);\n      if (error) {\n        return {\n          data: {\n            user: null,\n            session: null\n          },\n          error\n        };\n      } else if (!data || !data.session || !data.user) {\n        return {\n          data: {\n            user: null,\n            session: null\n          },\n          error: new AuthInvalidTokenResponseError()\n        };\n      }\n      if (data.session) {\n        yield this._saveSession(data.session);\n        yield this._notifyAllSubscribers('SIGNED_IN', data.session);\n      }\n      return {\n        data,\n        error\n      };\n    });\n  }\n  /**\n   * Allows signing in with an ID token issued by certain supported providers.\n   * The ID token is verified for validity and a new session is established.\n   *\n   * @experimental\n   */\n  signInWithIdToken(credentials) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._removeSession();\n      try {\n        const {\n          options,\n          provider,\n          token,\n          nonce\n        } = credentials;\n        const res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\n          headers: this.headers,\n          body: {\n            provider,\n            id_token: token,\n            nonce,\n            gotrue_meta_security: {\n              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n            }\n          },\n          xform: _sessionResponse\n        });\n        const {\n          data,\n          error\n        } = res;\n        if (error) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        } else if (!data || !data.session || !data.user) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: new AuthInvalidTokenResponseError()\n          };\n        }\n        if (data.session) {\n          yield this._saveSession(data.session);\n          yield this._notifyAllSubscribers('SIGNED_IN', data.session);\n        }\n        return {\n          data,\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in a user using magiclink or a one-time password (OTP).\n   *\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n   *\n   * Be aware that you may get back an error message that will not distinguish\n   * between the cases where the account does not exist or, that the account\n   * can only be accessed via social login.\n   *\n   * Do note that you will need to configure a Whatsapp sender on Twilio\n   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n   * channel is not supported on other providers\n   * at this time.\n   * This method supports PKCE when an email is passed.\n   */\n  signInWithOtp(credentials) {\n    var _a, _b, _c, _d, _e;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        if ('email' in credentials) {\n          const {\n            email,\n            options\n          } = credentials;\n          let codeChallenge = null;\n          let codeChallengeMethod = null;\n          if (this.flowType === 'pkce') {\n            const codeVerifier = generatePKCEVerifier();\n            yield setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);\n            codeChallenge = yield generatePKCEChallenge(codeVerifier);\n            codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n          }\n          const {\n            error\n          } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              email,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              },\n              code_challenge: codeChallenge,\n              code_challenge_method: codeChallengeMethod\n            },\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n          });\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        if ('phone' in credentials) {\n          const {\n            phone,\n            options\n          } = credentials;\n          const {\n            data,\n            error\n          } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              phone,\n              data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n              create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              },\n              channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : 'sms'\n            }\n          });\n          return {\n            data: {\n              user: null,\n              session: null,\n              messageId: data === null || data === void 0 ? void 0 : data.message_id\n            },\n            error\n          };\n        }\n        throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   */\n  verifyOtp(params) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (params.type !== 'email_change' && params.type !== 'phone_change') {\n          // we don't want to remove the authenticated session if the user is performing an email_change or phone_change verification\n          yield this._removeSession();\n        }\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/verify`, {\n          headers: this.headers,\n          body: Object.assign(Object.assign({}, params), {\n            gotrue_meta_security: {\n              captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken\n            }\n          }),\n          redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n          xform: _sessionResponse\n        });\n        if (error) {\n          throw error;\n        }\n        if (!data) {\n          throw new Error('An error occurred on token verification.');\n        }\n        const session = data.session;\n        const user = data.user;\n        if (session === null || session === void 0 ? void 0 : session.access_token) {\n          yield this._saveSession(session);\n          yield this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n        return {\n          data: {\n            user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Attempts a single-sign on using an enterprise Identity Provider. A\n   * successful SSO attempt will redirect the current page to the identity\n   * provider authorization page. The redirect URL is implementation and SSO\n   * protocol specific.\n   *\n   * You can use it by providing a SSO domain. Typically you can extract this\n   * domain by asking users for their email address. If this domain is\n   * registered on the Auth instance the redirect will use that organization's\n   * currently active SSO Identity Provider for the login.\n   *\n   * If you have built an organization-specific login page, you can use the\n   * organization's SSO Identity Provider UUID directly instead.\n   */\n  signInWithSSO(params) {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        return yield _request(this.fetch, 'POST', `${this.url}/sso`, {\n          body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {\n            provider_id: params.providerId\n          } : null), 'domain' in params ? {\n            domain: params.domain\n          } : null), {\n            redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n          }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n            gotrue_meta_security: {\n              captcha_token: params.options.captchaToken\n            }\n          } : null), {\n            skip_http_redirect: true\n          }),\n          headers: this.headers,\n          xform: _ssoResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Sends a reauthentication OTP to the user's email or phone number.\n   * Requires the user to be signed-in.\n   */\n  reauthenticate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: {\n            session\n          },\n          error: sessionError\n        } = yield this.getSession();\n        if (sessionError) throw sessionError;\n        if (!session) throw new AuthSessionMissingError();\n        const {\n          error\n        } = yield _request(this.fetch, 'GET', `${this.url}/reauthenticate`, {\n          headers: this.headers,\n          jwt: session.access_token\n        });\n        return {\n          data: {\n            user: null,\n            session: null\n          },\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n   */\n  resend(credentials) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        const endpoint = `${this.url}/resend`;\n        if ('email' in credentials) {\n          const {\n            email,\n            type,\n            options\n          } = credentials;\n          const {\n            error\n          } = yield _request(this.fetch, 'POST', endpoint, {\n            headers: this.headers,\n            body: {\n              email,\n              type,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            }\n          });\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        } else if ('phone' in credentials) {\n          const {\n            phone,\n            type,\n            options\n          } = credentials;\n          const {\n            data,\n            error\n          } = yield _request(this.fetch, 'POST', endpoint, {\n            headers: this.headers,\n            body: {\n              phone,\n              type,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            }\n          });\n          return {\n            data: {\n              user: null,\n              session: null,\n              messageId: data === null || data === void 0 ? void 0 : data.message_id\n            },\n            error\n          };\n        }\n        throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a type');\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Returns the session, refreshing it if necessary.\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n   */\n  getSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // make sure we've read the session from the url if there is one\n      // save to just await, as long we make sure _initialize() never throws\n      yield this.initializePromise;\n      let currentSession = null;\n      if (this.persistSession) {\n        const maybeSession = yield getItemAsync(this.storage, this.storageKey);\n        if (maybeSession !== null) {\n          if (this._isValidSession(maybeSession)) {\n            currentSession = maybeSession;\n          } else {\n            yield this._removeSession();\n          }\n        }\n      } else {\n        currentSession = this.inMemorySession;\n      }\n      if (!currentSession) {\n        return {\n          data: {\n            session: null\n          },\n          error: null\n        };\n      }\n      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;\n      if (!hasExpired) {\n        return {\n          data: {\n            session: currentSession\n          },\n          error: null\n        };\n      }\n      const {\n        session,\n        error\n      } = yield this._callRefreshToken(currentSession.refresh_token);\n      if (error) {\n        return {\n          data: {\n            session: null\n          },\n          error\n        };\n      }\n      return {\n        data: {\n          session\n        },\n        error: null\n      };\n    });\n  }\n  /**\n   * Gets the current user details if there is an existing session.\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n   */\n  getUser(jwt) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!jwt) {\n          const {\n            data,\n            error\n          } = yield this.getSession();\n          if (error) {\n            throw error;\n          }\n          // Default to Authorization header if there is no existing session\n          jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n        }\n        return yield _request(this.fetch, 'GET', `${this.url}/user`, {\n          headers: this.headers,\n          jwt: jwt,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Updates user data for a logged in user.\n   */\n  updateUser(attributes) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n        if (sessionError) {\n          throw sessionError;\n        }\n        if (!sessionData.session) {\n          throw new AuthSessionMissingError();\n        }\n        const session = sessionData.session;\n        const {\n          data,\n          error: userError\n        } = yield _request(this.fetch, 'PUT', `${this.url}/user`, {\n          headers: this.headers,\n          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n          body: attributes,\n          jwt: session.access_token,\n          xform: _userResponse\n        });\n        if (userError) throw userError;\n        session.user = data.user;\n        yield this._saveSession(session);\n        yield this._notifyAllSubscribers('USER_UPDATED', session);\n        return {\n          data: {\n            user: session.user\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Decodes a JWT (without performing any validation).\n   */\n  _decodeJWT(jwt) {\n    return decodeJWTPayload(jwt);\n  }\n  /**\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\n   * @param currentSession The current session that minimally contains an access token and refresh token.\n   */\n  setSession(currentSession) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!currentSession.access_token || !currentSession.refresh_token) {\n          throw new AuthSessionMissingError();\n        }\n        const timeNow = Date.now() / 1000;\n        let expiresAt = timeNow;\n        let hasExpired = true;\n        let session = null;\n        const payload = decodeJWTPayload(currentSession.access_token);\n        if (payload.exp) {\n          expiresAt = payload.exp;\n          hasExpired = expiresAt <= timeNow;\n        }\n        if (hasExpired) {\n          const {\n            session: refreshedSession,\n            error\n          } = yield this._callRefreshToken(currentSession.refresh_token);\n          if (error) {\n            return {\n              data: {\n                user: null,\n                session: null\n              },\n              error: error\n            };\n          }\n          if (!refreshedSession) {\n            return {\n              data: {\n                user: null,\n                session: null\n              },\n              error: null\n            };\n          }\n          session = refreshedSession;\n        } else {\n          const {\n            data,\n            error\n          } = yield this.getUser(currentSession.access_token);\n          if (error) {\n            throw error;\n          }\n          session = {\n            access_token: currentSession.access_token,\n            refresh_token: currentSession.refresh_token,\n            user: data.user,\n            token_type: 'bearer',\n            expires_in: expiresAt - timeNow,\n            expires_at: expiresAt\n          };\n          yield this._saveSession(session);\n          yield this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n        return {\n          data: {\n            user: session.user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              user: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Returns a new session, regardless of expiry status.\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n   * If the current session's refresh token is invalid, an error will be thrown.\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\n   */\n  refreshSession(currentSession) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!currentSession) {\n          const {\n            data,\n            error\n          } = yield this.getSession();\n          if (error) {\n            throw error;\n          }\n          currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n        }\n        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n          throw new AuthSessionMissingError();\n        }\n        const {\n          session,\n          error\n        } = yield this._callRefreshToken(currentSession.refresh_token);\n        if (error) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: error\n          };\n        }\n        if (!session) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: null\n          };\n        }\n        return {\n          data: {\n            user: session.user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Gets the session data from a URL string\n   */\n  _getSessionFromUrl(isPKCEFlow) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.');\n        if (this.flowType === 'implicit' && !this._isImplicitGrantFlow()) {\n          throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n        } else if (this.flowType == 'pkce' && !isPKCEFlow) {\n          throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.');\n        }\n        if (isPKCEFlow) {\n          const authCode = getParameterByName('code');\n          if (!authCode) throw new AuthPKCEGrantCodeExchangeError('No code detected.');\n          const {\n            data,\n            error\n          } = yield this.exchangeCodeForSession(authCode);\n          if (error) throw error;\n          if (!data.session) throw new AuthPKCEGrantCodeExchangeError('No session detected.');\n          let url = new URL(window.location.href);\n          url.searchParams.delete('code');\n          window.history.replaceState(window.history.state, '', url.toString());\n          return {\n            data: {\n              session: data.session,\n              redirectType: null\n            },\n            error: null\n          };\n        }\n        const error_description = getParameterByName('error_description');\n        if (error_description) {\n          const error_code = getParameterByName('error_code');\n          if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.');\n          const error = getParameterByName('error');\n          if (!error) throw new AuthImplicitGrantRedirectError('No error detected.');\n          throw new AuthImplicitGrantRedirectError(error_description, {\n            error,\n            code: error_code\n          });\n        }\n        const provider_token = getParameterByName('provider_token');\n        const provider_refresh_token = getParameterByName('provider_refresh_token');\n        const access_token = getParameterByName('access_token');\n        if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.');\n        const expires_in = getParameterByName('expires_in');\n        if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n        const refresh_token = getParameterByName('refresh_token');\n        if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n        const token_type = getParameterByName('token_type');\n        if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.');\n        const timeNow = Math.round(Date.now() / 1000);\n        const expires_at = timeNow + parseInt(expires_in);\n        const {\n          data,\n          error\n        } = yield this.getUser(access_token);\n        if (error) throw error;\n        const user = data.user;\n        const session = {\n          provider_token,\n          provider_refresh_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user\n        };\n        const redirectType = getParameterByName('type');\n        // Remove tokens from URL\n        window.location.hash = '';\n        return {\n          data: {\n            session,\n            redirectType\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              redirectType: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n   */\n  _isImplicitGrantFlow() {\n    return isBrowser() && (Boolean(getParameterByName('access_token')) || Boolean(getParameterByName('error_description')));\n  }\n  /**\n   * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n   */\n  _isPKCEFlow() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const currentStorageContent = yield getItemAsync(this.storage, `${this.storageKey}-code-verifier`);\n      return Boolean(getParameterByName('code')) && Boolean(currentStorageContent);\n    });\n  }\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n   */\n  signOut() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data,\n        error: sessionError\n      } = yield this.getSession();\n      if (sessionError) {\n        return {\n          error: sessionError\n        };\n      }\n      const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n      if (accessToken) {\n        const {\n          error\n        } = yield this.admin.signOut(accessToken);\n        if (error) {\n          // ignore 404s since user might not exist anymore\n          // ignore 401s since an invalid or expired JWT should sign out the current session\n          if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n            return {\n              error\n            };\n          }\n        }\n      }\n      yield this._removeSession();\n      yield removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);\n      yield this._notifyAllSubscribers('SIGNED_OUT', null);\n      return {\n        error: null\n      };\n    });\n  }\n  /**\n   * Receive a notification every time an auth event happens.\n   * @param callback A callback function to be invoked when an auth event happens.\n   */\n  onAuthStateChange(callback) {\n    const id = uuid();\n    const subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id);\n      }\n    };\n    this.stateChangeEmitters.set(id, subscription);\n    this.emitInitialSession(id);\n    return {\n      data: {\n        subscription\n      }\n    };\n  }\n  emitInitialSession(id) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: {\n            session\n          },\n          error\n        } = yield this.getSession();\n        if (error) throw error;\n        yield (_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback('INITIAL_SESSION', session);\n      } catch (err) {\n        yield (_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback('INITIAL_SESSION', null);\n        console.error(err);\n      }\n    });\n  }\n  /**\n   * Sends a password reset request to an email address.\n   * This method supports the PKCE flow.\n   * @param email The email address of the user.\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n   */\n  resetPasswordForEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      let codeChallenge = null;\n      let codeChallengeMethod = null;\n      if (this.flowType === 'pkce') {\n        const codeVerifier = generatePKCEVerifier();\n        yield setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);\n        codeChallenge = yield generatePKCEChallenge(codeVerifier);\n        codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n      }\n      try {\n        return yield _request(this.fetch, 'POST', `${this.url}/recover`, {\n          body: {\n            email,\n            code_challenge: codeChallenge,\n            code_challenge_method: codeChallengeMethod,\n            gotrue_meta_security: {\n              captcha_token: options.captchaToken\n            }\n          },\n          headers: this.headers,\n          redirectTo: options.redirectTo\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  _refreshAccessToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const startedAt = Date.now();\n        // will attempt to refresh the token with exponential backoff\n        return yield retryable(attempt => __awaiter(this, void 0, void 0, function* () {\n          yield sleep(attempt * 200); // 0, 200, 400, 800, ...\n          return yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n            body: {\n              refresh_token: refreshToken\n            },\n            headers: this.headers,\n            xform: _sessionResponse\n          });\n        }), (attempt, _, result) => result && result.error && result.error instanceof AuthRetryableFetchError &&\n        // retryable only if the request can be sent before the backoff overflows the tick duration\n        Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION);\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              user: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  _isValidSession(maybeSession) {\n    const isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;\n    return isValidSession;\n  }\n  _handleProviderSignIn(provider, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const url = yield this._getUrlForProvider(provider, {\n        redirectTo: options.redirectTo,\n        scopes: options.scopes,\n        queryParams: options.queryParams\n      });\n      // try to open on the browser\n      if (isBrowser() && !options.skipBrowserRedirect) {\n        window.location.assign(url);\n      }\n      return {\n        data: {\n          provider,\n          url\n        },\n        error: null\n      };\n    });\n  }\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  _recoverAndRefresh() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const currentSession = yield getItemAsync(this.storage, this.storageKey);\n        if (!this._isValidSession(currentSession)) {\n          if (currentSession !== null) {\n            yield this._removeSession();\n          }\n          return;\n        }\n        const timeNow = Math.round(Date.now() / 1000);\n        if (((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            const {\n              error\n            } = yield this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n              console.log(error.message);\n              yield this._removeSession();\n            }\n          }\n        } else {\n          if (this.persistSession) {\n            yield this._saveSession(currentSession);\n          }\n          yield this._notifyAllSubscribers('SIGNED_IN', currentSession);\n        }\n      } catch (err) {\n        console.error(err);\n        return;\n      }\n    });\n  }\n  _callRefreshToken(refreshToken) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      // refreshing is already in progress\n      if (this.refreshingDeferred) {\n        return this.refreshingDeferred.promise;\n      }\n      try {\n        this.refreshingDeferred = new Deferred();\n        if (!refreshToken) {\n          throw new AuthSessionMissingError();\n        }\n        const {\n          data,\n          error\n        } = yield this._refreshAccessToken(refreshToken);\n        if (error) throw error;\n        if (!data.session) throw new AuthSessionMissingError();\n        yield this._saveSession(data.session);\n        yield this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n        const result = {\n          session: data.session,\n          error: null\n        };\n        this.refreshingDeferred.resolve(result);\n        return result;\n      } catch (error) {\n        if (isAuthError(error)) {\n          const result = {\n            session: null,\n            error\n          };\n          (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n          return result;\n        }\n        (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n        throw error;\n      } finally {\n        this.refreshingDeferred = null;\n      }\n    });\n  }\n  _notifyAllSubscribers(event, session) {\n    let broadcast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.broadcastChannel && broadcast) {\n        this.broadcastChannel.postMessage({\n          event,\n          session\n        });\n      }\n      const errors = [];\n      const promises = Array.from(this.stateChangeEmitters.values()).map(x => __awaiter(this, void 0, void 0, function* () {\n        try {\n          yield x.callback(event, session);\n        } catch (e) {\n          errors.push(e);\n        }\n      }));\n      yield Promise.all(promises);\n      if (errors.length > 0) {\n        for (let i = 0; i < errors.length; i += 1) {\n          console.error(errors[i]);\n        }\n        throw errors[0];\n      }\n    });\n  }\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  _saveSession(session) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.persistSession) {\n        this.inMemorySession = session;\n      }\n      if (this.persistSession && session.expires_at) {\n        yield this._persistSession(session);\n      }\n    });\n  }\n  _persistSession(currentSession) {\n    return setItemAsync(this.storage, this.storageKey, currentSession);\n  }\n  _removeSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.persistSession) {\n        yield removeItemAsync(this.storage, this.storageKey);\n      } else {\n        this.inMemorySession = null;\n      }\n    });\n  }\n  /**\n   * Removes any registered visibilitychange callback.\n   *\n   * {@see #startAutoRefresh}\n   * {@see #stopAutoRefresh}\n   */\n  _removeVisibilityChangedCallback() {\n    const callback = this.visibilityChangedCallback;\n    this.visibilityChangedCallback = null;\n    try {\n      if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n        window.removeEventListener('visibilitychange', callback);\n      }\n    } catch (e) {\n      console.error('removing visibilitychange callback failed', e);\n    }\n  }\n  /**\n   * This is the private implementation of {@link #startAutoRefresh}. Use this\n   * within the library.\n   */\n  _startAutoRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._stopAutoRefresh();\n      const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION);\n      this.autoRefreshTicker = ticker;\n      if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n        // ticker is a NodeJS Timeout object that has an `unref` method\n        // https://nodejs.org/api/timers.html#timeoutunref\n        // When auto refresh is used in NodeJS (like for testing) the\n        // `setInterval` is preventing the process from being marked as\n        // finished and tests run endlessly. This can be prevented by calling\n        // `unref()` on the returned object.\n        ticker.unref();\n        // @ts-ignore\n      } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {\n        // similar like for NodeJS, but with the Deno API\n        // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n        // @ts-ignore\n        Deno.unrefTimer(ticker);\n      }\n      // run the tick immediately\n      yield this._autoRefreshTokenTick();\n    });\n  }\n  /**\n   * This is the private implementation of {@link #stopAutoRefresh}. Use this\n   * within the library.\n   */\n  _stopAutoRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ticker = this.autoRefreshTicker;\n      this.autoRefreshTicker = null;\n      if (ticker) {\n        clearInterval(ticker);\n      }\n    });\n  }\n  /**\n   * Starts an auto-refresh process in the background. The session is checked\n   * every few seconds. Close to the time of expiration a process is started to\n   * refresh the session. If refreshing fails it will be retried for as long as\n   * necessary.\n   *\n   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n   * to call this function, it will be called for you.\n   *\n   * On browsers the refresh process works only when the tab/window is in the\n   * foreground to conserve resources as well as prevent race conditions and\n   * flooding auth with requests. If you call this method any managed\n   * visibility change callback will be removed and you must manage visibility\n   * changes on your own.\n   *\n   * On non-browser platforms the refresh process works *continuously* in the\n   * background, which may not be desirable. You should hook into your\n   * platform's foreground indication mechanism and call these methods\n   * appropriately to conserve resources.\n   *\n   * {@see #stopAutoRefresh}\n   */\n  startAutoRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._removeVisibilityChangedCallback();\n      yield this._startAutoRefresh();\n    });\n  }\n  /**\n   * Stops an active auto refresh process running in the background (if any).\n   *\n   * If you call this method any managed visibility change callback will be\n   * removed and you must manage visibility changes on your own.\n   *\n   * See {@link #startAutoRefresh} for more details.\n   */\n  stopAutoRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._removeVisibilityChangedCallback();\n      yield this._stopAutoRefresh();\n    });\n  }\n  /**\n   * Runs the auto refresh token tick.\n   */\n  _autoRefreshTokenTick() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const now = Date.now();\n      try {\n        const {\n          data: {\n            session\n          }\n        } = yield this.getSession();\n        if (!session || !session.refresh_token || !session.expires_at) {\n          return;\n        }\n        // session will expire in this many ticks (or has already expired if <= 0)\n        const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION);\n        if (expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD) {\n          yield this._callRefreshToken(session.refresh_token);\n        }\n      } catch (e) {\n        console.error('Auto refresh tick failed with error. This is likely a transient error.', e);\n      }\n    });\n  }\n  /**\n   * Registers callbacks on the browser / platform, which in-turn run\n   * algorithms when the browser window/tab are in foreground. On non-browser\n   * platforms it assumes always foreground.\n   */\n  _handleVisibilityChange() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n        if (this.autoRefreshToken) {\n          // in non-browser environments the refresh token ticker runs always\n          this.startAutoRefresh();\n        }\n        return false;\n      }\n      try {\n        this.visibilityChangedCallback = () => __awaiter(this, void 0, void 0, function* () {\n          return yield this._onVisibilityChanged(false);\n        });\n        window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback);\n        // now immediately call the visbility changed callback to setup with the\n        // current visbility state\n        yield this._onVisibilityChanged(true); // initial call\n      } catch (error) {\n        console.error('_handleVisibilityChange', error);\n      }\n    });\n  }\n  /**\n   * Callback registered with `window.addEventListener('visibilitychange')`.\n   */\n  _onVisibilityChanged(isInitial) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (document.visibilityState === 'visible') {\n        if (!isInitial) {\n          // initial visibility change setup is handled in another flow under #initialize()\n          yield this.initializePromise;\n          yield this._recoverAndRefresh();\n        }\n        if (this.autoRefreshToken) {\n          // in browser environments the refresh token ticker runs only on focused tabs\n          // which prevents race conditions\n          this._startAutoRefresh();\n        }\n      } else if (document.visibilityState === 'hidden') {\n        if (this.autoRefreshToken) {\n          this._stopAutoRefresh();\n        }\n      }\n    });\n  }\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n   */\n  _getUrlForProvider(provider, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const urlParams = [`provider=${encodeURIComponent(provider)}`];\n      if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n      }\n      if (options === null || options === void 0 ? void 0 : options.scopes) {\n        urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n      }\n      if (this.flowType === 'pkce') {\n        const codeVerifier = generatePKCEVerifier();\n        yield setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);\n        const codeChallenge = yield generatePKCEChallenge(codeVerifier);\n        const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n        const flowParams = new URLSearchParams({\n          code_challenge: `${encodeURIComponent(codeChallenge)}`,\n          code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`\n        });\n        urlParams.push(flowParams.toString());\n      }\n      if (options === null || options === void 0 ? void 0 : options.queryParams) {\n        const query = new URLSearchParams(options.queryParams);\n        urlParams.push(query.toString());\n      }\n      return `${this.url}/authorize?${urlParams.join('&')}`;\n    });\n  }\n  _unenroll(params) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n        return yield _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * {@see GoTrueMFAApi#enroll}\n   */\n  _enroll(params) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/factors`, {\n          body: {\n            friendly_name: params.friendlyName,\n            factor_type: params.factorType,\n            issuer: params.issuer\n          },\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n        if (error) {\n          return {\n            data: null,\n            error\n          };\n        }\n        if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n        }\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * {@see GoTrueMFAApi#verify}\n   */\n  _verify(params) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/verify`, {\n          body: {\n            code: params.code,\n            challenge_id: params.challengeId\n          },\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n        if (error) {\n          return {\n            data: null,\n            error\n          };\n        }\n        yield this._saveSession(Object.assign({\n          expires_at: Math.round(Date.now() / 1000) + data.expires_in\n        }, data));\n        yield this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n        return {\n          data,\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * {@see GoTrueMFAApi#challenge}\n   */\n  _challenge(params) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n        return yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * {@see GoTrueMFAApi#challengeAndVerify}\n   */\n  _challengeAndVerify(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: challengeData,\n        error: challengeError\n      } = yield this._challenge({\n        factorId: params.factorId\n      });\n      if (challengeError) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n      return yield this._verify({\n        factorId: params.factorId,\n        challengeId: challengeData.id,\n        code: params.code\n      });\n    });\n  }\n  /**\n   * {@see GoTrueMFAApi#listFactors}\n   */\n  _listFactors() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: {\n          user\n        },\n        error: userError\n      } = yield this.getUser();\n      if (userError) {\n        return {\n          data: null,\n          error: userError\n        };\n      }\n      const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n      const totp = factors.filter(factor => factor.factor_type === 'totp' && factor.status === 'verified');\n      return {\n        data: {\n          all: factors,\n          totp\n        },\n        error: null\n      };\n    });\n  }\n  /**\n   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n   */\n  _getAuthenticatorAssuranceLevel() {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: {\n          session\n        },\n        error: sessionError\n      } = yield this.getSession();\n      if (sessionError) {\n        return {\n          data: null,\n          error: sessionError\n        };\n      }\n      if (!session) {\n        return {\n          data: {\n            currentLevel: null,\n            nextLevel: null,\n            currentAuthenticationMethods: []\n          },\n          error: null\n        };\n      }\n      const payload = this._decodeJWT(session.access_token);\n      let currentLevel = null;\n      if (payload.aal) {\n        currentLevel = payload.aal;\n      }\n      let nextLevel = currentLevel;\n      const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(factor => factor.status === 'verified')) !== null && _b !== void 0 ? _b : [];\n      if (verifiedFactors.length > 0) {\n        nextLevel = 'aal2';\n      }\n      const currentAuthenticationMethods = payload.amr || [];\n      return {\n        data: {\n          currentLevel,\n          nextLevel,\n          currentAuthenticationMethods\n        },\n        error: null\n      };\n    });\n  }\n}","map":{"version":3,"names":["GoTrueAdminApi","DEFAULT_HEADERS","EXPIRY_MARGIN","GOTRUE_URL","STORAGE_KEY","AuthImplicitGrantRedirectError","AuthPKCEGrantCodeExchangeError","AuthInvalidCredentialsError","AuthRetryableFetchError","AuthSessionMissingError","AuthInvalidTokenResponseError","AuthUnknownError","isAuthApiError","isAuthError","_request","_sessionResponse","_userResponse","_ssoResponse","decodeJWTPayload","Deferred","getItemAsync","getParameterByName","isBrowser","removeItemAsync","resolveFetch","setItemAsync","uuid","retryable","sleep","generatePKCEVerifier","generatePKCEChallenge","supportsLocalStorage","localStorageAdapter","polyfillGlobalThis","DEFAULT_OPTIONS","url","storageKey","autoRefreshToken","persistSession","detectSessionInUrl","headers","flowType","AUTO_REFRESH_TICK_DURATION","AUTO_REFRESH_TICK_THRESHOLD","GoTrueClient","constructor","options","stateChangeEmitters","Map","autoRefreshTicker","visibilityChangedCallback","refreshingDeferred","initializePromise","broadcastChannel","settings","Object","assign","inMemorySession","storage","admin","fetch","mfa","verify","_verify","bind","enroll","_enroll","unenroll","_unenroll","challenge","_challenge","listFactors","_listFactors","challengeAndVerify","_challengeAndVerify","getAuthenticatorAssuranceLevel","_getAuthenticatorAssuranceLevel","console","warn","globalThis","BroadcastChannel","e","error","_a","addEventListener","event","__awaiter","_notifyAllSubscribers","data","session","initialize","_initialize","isPKCEFlow","_isPKCEFlow","_isImplicitGrantFlow","_getSessionFromUrl","_removeSession","redirectType","_saveSession","setTimeout","_recoverAndRefresh","_handleVisibilityChange","signUp","credentials","res","email","password","codeChallenge","codeChallengeMethod","codeVerifier","redirectTo","emailRedirectTo","body","gotrue_meta_security","captcha_token","captchaToken","code_challenge","code_challenge_method","xform","phone","_b","channel","_c","user","signInWithPassword","signInWithOAuth","_handleProviderSignIn","provider","scopes","queryParams","skipBrowserRedirect","_d","exchangeCodeForSession","authCode","auth_code","code_verifier","signInWithIdToken","token","nonce","id_token","signInWithOtp","create_user","shouldCreateUser","_e","messageId","message_id","verifyOtp","params","type","Error","access_token","signInWithSSO","provider_id","providerId","domain","redirect_to","undefined","skip_http_redirect","reauthenticate","sessionError","getSession","jwt","resend","endpoint","currentSession","maybeSession","_isValidSession","hasExpired","expires_at","Date","now","_callRefreshToken","refresh_token","getUser","updateUser","attributes","arguments","length","sessionData","userError","_decodeJWT","setSession","timeNow","expiresAt","payload","exp","refreshedSession","token_type","expires_in","refreshSession","URL","window","location","href","searchParams","delete","history","replaceState","state","toString","error_description","error_code","code","provider_token","provider_refresh_token","Math","round","parseInt","hash","Boolean","currentStorageContent","signOut","accessToken","status","onAuthStateChange","callback","id","subscription","unsubscribe","set","emitInitialSession","get","err","resetPasswordForEmail","_refreshAccessToken","refreshToken","startedAt","attempt","_","result","isValidSession","_getUrlForProvider","Infinity","log","message","promise","resolve","reject","broadcast","postMessage","errors","promises","Array","from","values","map","x","push","Promise","all","i","_persistSession","_removeVisibilityChangedCallback","removeEventListener","_startAutoRefresh","_stopAutoRefresh","ticker","setInterval","_autoRefreshTokenTick","unref","Deno","unrefTimer","clearInterval","startAutoRefresh","stopAutoRefresh","expiresInTicks","floor","_onVisibilityChanged","isInitial","document","visibilityState","urlParams","encodeURIComponent","flowParams","URLSearchParams","query","join","factorId","friendly_name","friendlyName","factor_type","factorType","issuer","totp","qr_code","challenge_id","challengeId","challengeData","challengeError","factors","filter","factor","currentLevel","nextLevel","currentAuthenticationMethods","aal","verifiedFactors","amr"],"sources":["C:\\expense-tracker\\expense-tracker-react-app\\node_modules\\@supabase\\gotrue-js\\src\\GoTrueClient.ts"],"sourcesContent":["import GoTrueAdminApi from './GoTrueAdminApi'\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants'\nimport {\n  AuthError,\n  AuthImplicitGrantRedirectError,\n  AuthPKCEGrantCodeExchangeError,\n  AuthInvalidCredentialsError,\n  AuthRetryableFetchError,\n  AuthSessionMissingError,\n  AuthInvalidTokenResponseError,\n  AuthUnknownError,\n  isAuthApiError,\n  isAuthError,\n} from './lib/errors'\nimport { Fetch, _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch'\nimport {\n  decodeJWTPayload,\n  Deferred,\n  getItemAsync,\n  getParameterByName,\n  isBrowser,\n  removeItemAsync,\n  resolveFetch,\n  setItemAsync,\n  uuid,\n  retryable,\n  sleep,\n  generatePKCEVerifier,\n  generatePKCEChallenge,\n  supportsLocalStorage,\n} from './lib/helpers'\nimport localStorageAdapter from './lib/local-storage'\nimport { polyfillGlobalThis } from './lib/polyfills'\n\nimport type {\n  AuthChangeEvent,\n  AuthResponse,\n  AuthTokenResponse,\n  AuthOtpResponse,\n  CallRefreshTokenResult,\n  GoTrueClientOptions,\n  InitializeResult,\n  OAuthResponse,\n  SSOResponse,\n  Provider,\n  Session,\n  SignInWithIdTokenCredentials,\n  SignInWithOAuthCredentials,\n  SignInWithPasswordCredentials,\n  SignInWithPasswordlessCredentials,\n  SignUpWithPasswordCredentials,\n  SignInWithSSO,\n  Subscription,\n  SupportedStorage,\n  User,\n  UserAttributes,\n  UserResponse,\n  VerifyOtpParams,\n  GoTrueMFAApi,\n  MFAEnrollParams,\n  AuthMFAEnrollResponse,\n  MFAChallengeParams,\n  AuthMFAChallengeResponse,\n  MFAUnenrollParams,\n  AuthMFAUnenrollResponse,\n  MFAVerifyParams,\n  AuthMFAVerifyResponse,\n  AuthMFAListFactorsResponse,\n  AMREntry,\n  AuthMFAGetAuthenticatorAssuranceLevelResponse,\n  AuthenticatorAssuranceLevels,\n  Factor,\n  MFAChallengeAndVerifyParams,\n  ResendParams,\n  AuthFlowType,\n} from './lib/types'\n\npolyfillGlobalThis() // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS: Omit<Required<GoTrueClientOptions>, 'fetch' | 'storage'> = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n  flowType: 'implicit',\n}\n\n/** Current session will be checked for refresh at this interval. */\nconst AUTO_REFRESH_TICK_DURATION = 30 * 1000\n\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\nconst AUTO_REFRESH_TICK_THRESHOLD = 3\n\nexport default class GoTrueClient {\n  /**\n   * Namespace for the GoTrue admin methods.\n   * These methods should only be used in a trusted server-side environment.\n   */\n  admin: GoTrueAdminApi\n  /**\n   * Namespace for the MFA methods.\n   */\n  mfa: GoTrueMFAApi\n  /**\n   * The storage key used to identify the values saved in localStorage\n   */\n  protected storageKey: string\n\n  /**\n   * The session object for the currently logged in user. If null, it means there isn't a logged-in user.\n   * Only used if persistSession is false.\n   */\n  protected inMemorySession: Session | null\n\n  protected flowType: AuthFlowType\n\n  protected autoRefreshToken: boolean\n  protected persistSession: boolean\n  protected storage: SupportedStorage\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\n  protected autoRefreshTicker: ReturnType<typeof setInterval> | null = null\n  protected visibilityChangedCallback: (() => Promise<any>) | null = null\n  protected refreshingDeferred: Deferred<CallRefreshTokenResult> | null = null\n  /**\n   * Keeps track of the async client initialization.\n   * When null or not yet resolved the auth state is `unknown`\n   * Once resolved the the auth state is known and it's save to call any further client methods.\n   * Keep extra care to never reject or throw uncaught errors\n   */\n  protected initializePromise: Promise<InitializeResult> | null = null\n  protected detectSessionInUrl = true\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected fetch: Fetch\n\n  /**\n   * Used to broadcast state change events to other tabs listening.\n   */\n  protected broadcastChannel: BroadcastChannel | null = null\n\n  /**\n   * Create a new client for use in the browser.\n   */\n  constructor(options: GoTrueClientOptions) {\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n    this.inMemorySession = null\n    this.storageKey = settings.storageKey\n    this.autoRefreshToken = settings.autoRefreshToken\n    this.persistSession = settings.persistSession\n    this.storage = settings.storage || localStorageAdapter\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch,\n    })\n\n    this.url = settings.url\n    this.headers = settings.headers\n    this.fetch = resolveFetch(settings.fetch)\n    this.detectSessionInUrl = settings.detectSessionInUrl\n    this.flowType = settings.flowType\n\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n    }\n\n    if (this.persistSession && this.storage === localStorageAdapter && !supportsLocalStorage()) {\n      console.warn(\n        `No storage option exists to persist the session, which may result in unexpected behavior when using auth.\n        If you want to set persistSession to true, please provide a storage option or you may set persistSession to false to disable this warning.`\n      )\n    }\n\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n      try {\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)\n      } catch (e: any) {\n        console.error(\n          'Failed to create a new BroadcastChannel, multi-tab state changes will not be available',\n          e\n        )\n      }\n\n      this.broadcastChannel?.addEventListener('message', async (event) => {\n        await this._notifyAllSubscribers(event.data.event, event.data.session, false) // broadcast = false so we don't get an endless loop of messages\n      })\n    }\n\n    this.initialize()\n  }\n\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n  initialize(): Promise<InitializeResult> {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize()\n    }\n\n    return this.initializePromise\n  }\n\n  /**\n   * IMPORTANT:\n   * 1. Never throw in this method, as it is called from the constructor\n   * 2. Never return a session from this method as it would be cached over\n   *    the whole lifetime of the client\n   */\n  private async _initialize(): Promise<InitializeResult> {\n    if (this.initializePromise) {\n      return this.initializePromise\n    }\n\n    try {\n      const isPKCEFlow = isBrowser() ? await this._isPKCEFlow() : false\n      if (isPKCEFlow || (this.detectSessionInUrl && this._isImplicitGrantFlow())) {\n        const { data, error } = await this._getSessionFromUrl(isPKCEFlow)\n        if (error) {\n          // failed login attempt via url,\n          // remove old session as in verifyOtp, signUp and signInWith*\n          await this._removeSession()\n\n          return { error }\n        }\n\n        const { session, redirectType } = data\n\n        await this._saveSession(session)\n\n        setTimeout(async () => {\n          if (redirectType === 'recovery') {\n            await this._notifyAllSubscribers('PASSWORD_RECOVERY', session)\n          } else {\n            await this._notifyAllSubscribers('SIGNED_IN', session)\n          }\n        }, 0)\n\n        return { error: null }\n      }\n\n      // no login attempt via callback url try to recover session from storage\n      await this._recoverAndRefresh()\n      return { error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { error }\n      }\n\n      return {\n        error: new AuthUnknownError('Unexpected error during initialization', error),\n      }\n    } finally {\n      await this._handleVisibilityChange()\n    }\n  }\n\n  /**\n   * Creates a new user.\n   *\n   * Be aware that if a user account exists in the system you may get back an\n   * error message that attempts to hide this information from the user.\n   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUp(credentials: SignUpWithPasswordCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        let codeChallenge: string | null = null\n        let codeChallengeMethod: string | null = null\n        if (this.flowType === 'pkce') {\n          const codeVerifier = generatePKCEVerifier()\n          await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n          codeChallenge = await generatePKCEChallenge(codeVerifier)\n          codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n        }\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          redirectTo: options?.emailRedirectTo,\n          body: {\n            email,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            code_challenge: codeChallenge,\n            code_challenge_method: codeChallengeMethod,\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            data: options?.data ?? {},\n            channel: options?.channel ?? 'sms',\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n\n      const { data, error } = res\n\n      if (error || !data) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      const session: Session | null = data.session\n      const user: User | null = data.user\n\n      if (data.session) {\n        await this._saveSession(data.session)\n        await this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user with an email and password or phone and password.\n   *\n   * Be aware that you may get back an error message that will not distinguish\n   * between the cases where the account does not exist or that the\n   * email/phone and password combination is wrong or that the account can only\n   * be accessed via social login.\n   */\n  async signInWithPassword(credentials: SignInWithPasswordCredentials): Promise<AuthTokenResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            email,\n            password,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n      const { data, error } = res\n\n      if (error) {\n        return { data: { user: null, session: null }, error }\n      } else if (!data || !data.session || !data.user) {\n        return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() }\n      }\n      if (data.session) {\n        await this._saveSession(data.session)\n        await this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data: { user: data.user, session: data.session }, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user via a third-party provider.\n   * This method supports the PKCE flow.\n   */\n  async signInWithOAuth(credentials: SignInWithOAuthCredentials): Promise<OAuthResponse> {\n    await this._removeSession()\n\n    return await this._handleProviderSignIn(credentials.provider, {\n      redirectTo: credentials.options?.redirectTo,\n      scopes: credentials.options?.scopes,\n      queryParams: credentials.options?.queryParams,\n      skipBrowserRedirect: credentials.options?.skipBrowserRedirect,\n    })\n  }\n\n  /**\n   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n   */\n  async exchangeCodeForSession(authCode: string): Promise<AuthTokenResponse> {\n    const codeVerifier = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n    const { data, error } = await _request(\n      this.fetch,\n      'POST',\n      `${this.url}/token?grant_type=pkce`,\n      {\n        headers: this.headers,\n        body: {\n          auth_code: authCode,\n          code_verifier: codeVerifier,\n        },\n        xform: _sessionResponse,\n      }\n    )\n    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n    if (error) {\n      return { data: { user: null, session: null }, error }\n    } else if (!data || !data.session || !data.user) {\n      return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() }\n    }\n    if (data.session) {\n      await this._saveSession(data.session)\n      await this._notifyAllSubscribers('SIGNED_IN', data.session)\n    }\n    return { data, error }\n  }\n\n  /**\n   * Allows signing in with an ID token issued by certain supported providers.\n   * The ID token is verified for validity and a new session is established.\n   *\n   * @experimental\n   */\n  async signInWithIdToken(credentials: SignInWithIdTokenCredentials): Promise<AuthTokenResponse> {\n    await this._removeSession()\n\n    try {\n      const { options, provider, token, nonce } = credentials\n\n      const res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\n        headers: this.headers,\n        body: {\n          provider,\n          id_token: token,\n          nonce,\n          gotrue_meta_security: { captcha_token: options?.captchaToken },\n        },\n        xform: _sessionResponse,\n      })\n\n      const { data, error } = res\n      if (error) {\n        return { data: { user: null, session: null }, error }\n      } else if (!data || !data.session || !data.user) {\n        return {\n          data: { user: null, session: null },\n          error: new AuthInvalidTokenResponseError(),\n        }\n      }\n      if (data.session) {\n        await this._saveSession(data.session)\n        await this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Log in a user using magiclink or a one-time password (OTP).\n   *\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n   *\n   * Be aware that you may get back an error message that will not distinguish\n   * between the cases where the account does not exist or, that the account\n   * can only be accessed via social login.\n   *\n   * Do note that you will need to configure a Whatsapp sender on Twilio\n   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n   * channel is not supported on other providers\n   * at this time.\n   * This method supports PKCE when an email is passed.\n   */\n  async signInWithOtp(credentials: SignInWithPasswordlessCredentials): Promise<AuthOtpResponse> {\n    try {\n      await this._removeSession()\n\n      if ('email' in credentials) {\n        const { email, options } = credentials\n        let codeChallenge: string | null = null\n        let codeChallengeMethod: string | null = null\n        if (this.flowType === 'pkce') {\n          const codeVerifier = generatePKCEVerifier()\n          await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n          codeChallenge = await generatePKCEChallenge(codeVerifier)\n          codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n        }\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            email,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            code_challenge: codeChallenge,\n            code_challenge_method: codeChallengeMethod,\n          },\n          redirectTo: options?.emailRedirectTo,\n        })\n        return { data: { user: null, session: null }, error }\n      }\n      if ('phone' in credentials) {\n        const { phone, options } = credentials\n        const { data, error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            phone,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            channel: options?.channel ?? 'sms',\n          },\n        })\n        return { data: { user: null, session: null, messageId: data?.message_id }, error }\n      }\n      throw new AuthInvalidCredentialsError('You must provide either an email or phone number.')\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   */\n  async verifyOtp(params: VerifyOtpParams): Promise<AuthResponse> {\n    try {\n      if (params.type !== 'email_change' && params.type !== 'phone_change') {\n        // we don't want to remove the authenticated session if the user is performing an email_change or phone_change verification\n        await this._removeSession()\n      }\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/verify`, {\n        headers: this.headers,\n        body: {\n          ...params,\n          gotrue_meta_security: { captcha_token: params.options?.captchaToken },\n        },\n        redirectTo: params.options?.redirectTo,\n        xform: _sessionResponse,\n      })\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw new Error('An error occurred on token verification.')\n      }\n\n      const session: Session | null = data.session\n      const user: User = data.user\n\n      if (session?.access_token) {\n        await this._saveSession(session as Session)\n        await this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Attempts a single-sign on using an enterprise Identity Provider. A\n   * successful SSO attempt will redirect the current page to the identity\n   * provider authorization page. The redirect URL is implementation and SSO\n   * protocol specific.\n   *\n   * You can use it by providing a SSO domain. Typically you can extract this\n   * domain by asking users for their email address. If this domain is\n   * registered on the Auth instance the redirect will use that organization's\n   * currently active SSO Identity Provider for the login.\n   *\n   * If you have built an organization-specific login page, you can use the\n   * organization's SSO Identity Provider UUID directly instead.\n   */\n  async signInWithSSO(params: SignInWithSSO): Promise<SSOResponse> {\n    try {\n      await this._removeSession()\n\n      return await _request(this.fetch, 'POST', `${this.url}/sso`, {\n        body: {\n          ...('providerId' in params ? { provider_id: params.providerId } : null),\n          ...('domain' in params ? { domain: params.domain } : null),\n          redirect_to: params.options?.redirectTo ?? undefined,\n          ...(params?.options?.captchaToken\n            ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\n            : null),\n          skip_http_redirect: true, // fetch does not handle redirects\n        },\n        headers: this.headers,\n        xform: _ssoResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Sends a reauthentication OTP to the user's email or phone number.\n   * Requires the user to be signed-in.\n   */\n  async reauthenticate(): Promise<AuthResponse> {\n    try {\n      const {\n        data: { session },\n        error: sessionError,\n      } = await this.getSession()\n      if (sessionError) throw sessionError\n      if (!session) throw new AuthSessionMissingError()\n\n      const { error } = await _request(this.fetch, 'GET', `${this.url}/reauthenticate`, {\n        headers: this.headers,\n        jwt: session.access_token,\n      })\n      return { data: { user: null, session: null }, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n   */\n  async resend(credentials: ResendParams): Promise<AuthOtpResponse> {\n    try {\n      await this._removeSession()\n      const endpoint = `${this.url}/resend`\n      if ('email' in credentials) {\n        const { email, type, options } = credentials\n        const { error } = await _request(this.fetch, 'POST', endpoint, {\n          headers: this.headers,\n          body: {\n            email,\n            type,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n        })\n        return { data: { user: null, session: null }, error }\n      } else if ('phone' in credentials) {\n        const { phone, type, options } = credentials\n        const { data, error } = await _request(this.fetch, 'POST', endpoint, {\n          headers: this.headers,\n          body: {\n            phone,\n            type,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n        })\n        return { data: { user: null, session: null, messageId: data?.message_id }, error }\n      }\n      throw new AuthInvalidCredentialsError(\n        'You must provide either an email or phone number and a type'\n      )\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Returns the session, refreshing it if necessary.\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n   */\n  async getSession(): Promise<\n    | {\n        data: {\n          session: Session\n        }\n        error: null\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: AuthError\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: null\n      }\n  > {\n    // make sure we've read the session from the url if there is one\n    // save to just await, as long we make sure _initialize() never throws\n    await this.initializePromise\n\n    let currentSession: Session | null = null\n\n    if (this.persistSession) {\n      const maybeSession = await getItemAsync(this.storage, this.storageKey)\n\n      if (maybeSession !== null) {\n        if (this._isValidSession(maybeSession)) {\n          currentSession = maybeSession\n        } else {\n          await this._removeSession()\n        }\n      }\n    } else {\n      currentSession = this.inMemorySession\n    }\n\n    if (!currentSession) {\n      return { data: { session: null }, error: null }\n    }\n\n    const hasExpired = currentSession.expires_at\n      ? currentSession.expires_at <= Date.now() / 1000\n      : false\n    if (!hasExpired) {\n      return { data: { session: currentSession }, error: null }\n    }\n\n    const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n    if (error) {\n      return { data: { session: null }, error }\n    }\n\n    return { data: { session }, error: null }\n  }\n\n  /**\n   * Gets the current user details if there is an existing session.\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n   */\n  async getUser(jwt?: string): Promise<UserResponse> {\n    try {\n      if (!jwt) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        // Default to Authorization header if there is no existing session\n        jwt = data.session?.access_token ?? undefined\n      }\n\n      return await _request(this.fetch, 'GET', `${this.url}/user`, {\n        headers: this.headers,\n        jwt: jwt,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates user data for a logged in user.\n   */\n  async updateUser(\n    attributes: UserAttributes,\n    options: {\n      emailRedirectTo?: string | undefined\n    } = {}\n  ): Promise<UserResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        throw sessionError\n      }\n      if (!sessionData.session) {\n        throw new AuthSessionMissingError()\n      }\n      const session: Session = sessionData.session\n      const { data, error: userError } = await _request(this.fetch, 'PUT', `${this.url}/user`, {\n        headers: this.headers,\n        redirectTo: options?.emailRedirectTo,\n        body: attributes,\n        jwt: session.access_token,\n        xform: _userResponse,\n      })\n      if (userError) throw userError\n      session.user = data.user as User\n      await this._saveSession(session)\n      await this._notifyAllSubscribers('USER_UPDATED', session)\n\n      return { data: { user: session.user }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Decodes a JWT (without performing any validation).\n   */\n  private _decodeJWT(jwt: string): {\n    exp?: number\n    aal?: AuthenticatorAssuranceLevels | null\n    amr?: AMREntry[] | null\n  } {\n    return decodeJWTPayload(jwt)\n  }\n\n  /**\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\n   * @param currentSession The current session that minimally contains an access token and refresh token.\n   */\n  async setSession(currentSession: {\n    access_token: string\n    refresh_token: string\n  }): Promise<AuthResponse> {\n    try {\n      if (!currentSession.access_token || !currentSession.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const timeNow = Date.now() / 1000\n      let expiresAt = timeNow\n      let hasExpired = true\n      let session: Session | null = null\n      const payload = decodeJWTPayload(currentSession.access_token)\n      if (payload.exp) {\n        expiresAt = payload.exp\n        hasExpired = expiresAt <= timeNow\n      }\n\n      if (hasExpired) {\n        const { session: refreshedSession, error } = await this._callRefreshToken(\n          currentSession.refresh_token\n        )\n        if (error) {\n          return { data: { user: null, session: null }, error: error }\n        }\n\n        if (!refreshedSession) {\n          return { data: { user: null, session: null }, error: null }\n        }\n        session = refreshedSession\n      } else {\n        const { data, error } = await this.getUser(currentSession.access_token)\n        if (error) {\n          throw error\n        }\n        session = {\n          access_token: currentSession.access_token,\n          refresh_token: currentSession.refresh_token,\n          user: data.user,\n          token_type: 'bearer',\n          expires_in: expiresAt - timeNow,\n          expires_at: expiresAt,\n        }\n        await this._saveSession(session)\n        await this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Returns a new session, regardless of expiry status.\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n   * If the current session's refresh token is invalid, an error will be thrown.\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\n   */\n  async refreshSession(currentSession?: { refresh_token: string }): Promise<AuthResponse> {\n    try {\n      if (!currentSession) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        currentSession = data.session ?? undefined\n      }\n\n      if (!currentSession?.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n      if (error) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      if (!session) {\n        return { data: { user: null, session: null }, error: null }\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Gets the session data from a URL string\n   */\n  private async _getSessionFromUrl(isPKCEFlow: boolean): Promise<\n    | {\n        data: { session: Session; redirectType: string | null }\n        error: null\n      }\n    | { data: { session: null; redirectType: null }; error: AuthError }\n  > {\n    try {\n      if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.')\n      if (this.flowType === 'implicit' && !this._isImplicitGrantFlow()) {\n        throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.')\n      } else if (this.flowType == 'pkce' && !isPKCEFlow) {\n        throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.')\n      }\n      if (isPKCEFlow) {\n        const authCode = getParameterByName('code')\n        if (!authCode) throw new AuthPKCEGrantCodeExchangeError('No code detected.')\n        const { data, error } = await this.exchangeCodeForSession(authCode)\n        if (error) throw error\n        if (!data.session) throw new AuthPKCEGrantCodeExchangeError('No session detected.')\n        let url = new URL(window.location.href)\n        url.searchParams.delete('code')\n        window.history.replaceState(window.history.state, '', url.toString())\n        return { data: { session: data.session, redirectType: null }, error: null }\n      }\n\n      const error_description = getParameterByName('error_description')\n      if (error_description) {\n        const error_code = getParameterByName('error_code')\n        if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.')\n        const error = getParameterByName('error')\n        if (!error) throw new AuthImplicitGrantRedirectError('No error detected.')\n\n        throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code })\n      }\n\n      const provider_token = getParameterByName('provider_token')\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\n      const access_token = getParameterByName('access_token')\n      if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.')\n      const expires_in = getParameterByName('expires_in')\n      if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.')\n      const refresh_token = getParameterByName('refresh_token')\n      if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.')\n      const token_type = getParameterByName('token_type')\n      if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.')\n\n      const timeNow = Math.round(Date.now() / 1000)\n      const expires_at = timeNow + parseInt(expires_in)\n\n      const { data, error } = await this.getUser(access_token)\n      if (error) throw error\n      const user: User = data.user\n      const session: Session = {\n        provider_token,\n        provider_refresh_token,\n        access_token,\n        expires_in: parseInt(expires_in),\n        expires_at,\n        refresh_token,\n        token_type,\n        user,\n      }\n      const redirectType = getParameterByName('type')\n\n      // Remove tokens from URL\n      window.location.hash = ''\n\n      return { data: { session, redirectType }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, redirectType: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n   */\n  private _isImplicitGrantFlow(): boolean {\n    return (\n      isBrowser() &&\n      (Boolean(getParameterByName('access_token')) ||\n        Boolean(getParameterByName('error_description')))\n    )\n  }\n  /**\n   * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n   */\n  private async _isPKCEFlow(): Promise<boolean> {\n    const currentStorageContent = await getItemAsync(\n      this.storage,\n      `${this.storageKey}-code-verifier`\n    )\n    return Boolean(getParameterByName('code')) && Boolean(currentStorageContent)\n  }\n\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n   */\n  async signOut(): Promise<{ error: AuthError | null }> {\n    const { data, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { error: sessionError }\n    }\n    const accessToken = data.session?.access_token\n    if (accessToken) {\n      const { error } = await this.admin.signOut(accessToken)\n      if (error) {\n        // ignore 404s since user might not exist anymore\n        // ignore 401s since an invalid or expired JWT should sign out the current session\n        if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n          return { error }\n        }\n      }\n    }\n    await this._removeSession()\n    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n    await this._notifyAllSubscribers('SIGNED_OUT', null)\n    return { error: null }\n  }\n\n  /**\n   * Receive a notification every time an auth event happens.\n   * @param callback A callback function to be invoked when an auth event happens.\n   */\n  onAuthStateChange(\n    callback: (event: AuthChangeEvent, session: Session | null) => void | Promise<void>\n  ): {\n    data: { subscription: Subscription }\n  } {\n    const id: string = uuid()\n    const subscription: Subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id)\n      },\n    }\n\n    this.stateChangeEmitters.set(id, subscription)\n\n    this.emitInitialSession(id)\n\n    return { data: { subscription } }\n  }\n\n  private async emitInitialSession(id: string): Promise<void> {\n    try {\n      const {\n        data: { session },\n        error,\n      } = await this.getSession()\n      if (error) throw error\n\n      await this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', session)\n    } catch (err) {\n      await this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', null)\n      console.error(err)\n    }\n  }\n\n  /**\n   * Sends a password reset request to an email address.\n   * This method supports the PKCE flow.\n   * @param email The email address of the user.\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<\n    | {\n        data: {}\n        error: null\n      }\n    | { data: null; error: AuthError }\n  > {\n    let codeChallenge: string | null = null\n    let codeChallengeMethod: string | null = null\n    if (this.flowType === 'pkce') {\n      const codeVerifier = generatePKCEVerifier()\n      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n      codeChallenge = await generatePKCEChallenge(codeVerifier)\n      codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n    }\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/recover`, {\n        body: {\n          email,\n          code_challenge: codeChallenge,\n          code_challenge_method: codeChallengeMethod,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  private async _refreshAccessToken(refreshToken: string): Promise<AuthResponse> {\n    try {\n      const startedAt = Date.now()\n\n      // will attempt to refresh the token with exponential backoff\n      return await retryable(\n        async (attempt) => {\n          await sleep(attempt * 200) // 0, 200, 400, 800, ...\n\n          return await _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n            body: { refresh_token: refreshToken },\n            headers: this.headers,\n            xform: _sessionResponse,\n          })\n        },\n        (attempt, _, result) =>\n          result &&\n          result.error &&\n          result.error instanceof AuthRetryableFetchError &&\n          // retryable only if the request can be sent before the backoff overflows the tick duration\n          Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION\n      )\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n      throw error\n    }\n  }\n\n  private _isValidSession(maybeSession: unknown): maybeSession is Session {\n    const isValidSession =\n      typeof maybeSession === 'object' &&\n      maybeSession !== null &&\n      'access_token' in maybeSession &&\n      'refresh_token' in maybeSession &&\n      'expires_at' in maybeSession\n\n    return isValidSession\n  }\n\n  private async _handleProviderSignIn(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n      skipBrowserRedirect?: boolean\n    }\n  ) {\n    const url: string = await this._getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams,\n    })\n    // try to open on the browser\n    if (isBrowser() && !options.skipBrowserRedirect) {\n      window.location.assign(url)\n    }\n\n    return { data: { provider, url }, error: null }\n  }\n\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  private async _recoverAndRefresh() {\n    try {\n      const currentSession = await getItemAsync(this.storage, this.storageKey)\n      if (!this._isValidSession(currentSession)) {\n        if (currentSession !== null) {\n          await this._removeSession()\n        }\n\n        return\n      }\n\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if ((currentSession.expires_at ?? Infinity) < timeNow + EXPIRY_MARGIN) {\n        if (this.autoRefreshToken && currentSession.refresh_token) {\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\n\n          if (error) {\n            console.log(error.message)\n            await this._removeSession()\n          }\n        }\n      } else {\n        if (this.persistSession) {\n          await this._saveSession(currentSession)\n        }\n        await this._notifyAllSubscribers('SIGNED_IN', currentSession)\n      }\n    } catch (err) {\n      console.error(err)\n      return\n    }\n  }\n\n  private async _callRefreshToken(refreshToken: string): Promise<CallRefreshTokenResult> {\n    // refreshing is already in progress\n    if (this.refreshingDeferred) {\n      return this.refreshingDeferred.promise\n    }\n\n    try {\n      this.refreshingDeferred = new Deferred<CallRefreshTokenResult>()\n\n      if (!refreshToken) {\n        throw new AuthSessionMissingError()\n      }\n      const { data, error } = await this._refreshAccessToken(refreshToken)\n      if (error) throw error\n      if (!data.session) throw new AuthSessionMissingError()\n\n      await this._saveSession(data.session)\n      await this._notifyAllSubscribers('TOKEN_REFRESHED', data.session)\n\n      const result = { session: data.session, error: null }\n\n      this.refreshingDeferred.resolve(result)\n\n      return result\n    } catch (error) {\n      if (isAuthError(error)) {\n        const result = { session: null, error }\n\n        this.refreshingDeferred?.resolve(result)\n\n        return result\n      }\n\n      this.refreshingDeferred?.reject(error)\n      throw error\n    } finally {\n      this.refreshingDeferred = null\n    }\n  }\n\n  private async _notifyAllSubscribers(\n    event: AuthChangeEvent,\n    session: Session | null,\n    broadcast = true\n  ) {\n    if (this.broadcastChannel && broadcast) {\n      this.broadcastChannel.postMessage({ event, session })\n    }\n\n    const errors: any[] = []\n    const promises = Array.from(this.stateChangeEmitters.values()).map(async (x) => {\n      try {\n        await x.callback(event, session)\n      } catch (e: any) {\n        errors.push(e)\n      }\n    })\n\n    await Promise.all(promises)\n\n    if (errors.length > 0) {\n      for (let i = 0; i < errors.length; i += 1) {\n        console.error(errors[i])\n      }\n\n      throw errors[0]\n    }\n  }\n\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  private async _saveSession(session: Session) {\n    if (!this.persistSession) {\n      this.inMemorySession = session\n    }\n\n    if (this.persistSession && session.expires_at) {\n      await this._persistSession(session)\n    }\n  }\n\n  private _persistSession(currentSession: Session) {\n    return setItemAsync(this.storage, this.storageKey, currentSession)\n  }\n\n  private async _removeSession() {\n    if (this.persistSession) {\n      await removeItemAsync(this.storage, this.storageKey)\n    } else {\n      this.inMemorySession = null\n    }\n  }\n\n  /**\n   * Removes any registered visibilitychange callback.\n   *\n   * {@see #startAutoRefresh}\n   * {@see #stopAutoRefresh}\n   */\n  private _removeVisibilityChangedCallback() {\n    const callback = this.visibilityChangedCallback\n    this.visibilityChangedCallback = null\n\n    try {\n      if (callback && isBrowser() && window?.removeEventListener) {\n        window.removeEventListener('visibilitychange', callback)\n      }\n    } catch (e) {\n      console.error('removing visibilitychange callback failed', e)\n    }\n  }\n\n  /**\n   * This is the private implementation of {@link #startAutoRefresh}. Use this\n   * within the library.\n   */\n  private async _startAutoRefresh() {\n    await this._stopAutoRefresh()\n\n    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION)\n    this.autoRefreshTicker = ticker\n\n    if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n      // ticker is a NodeJS Timeout object that has an `unref` method\n      // https://nodejs.org/api/timers.html#timeoutunref\n      // When auto refresh is used in NodeJS (like for testing) the\n      // `setInterval` is preventing the process from being marked as\n      // finished and tests run endlessly. This can be prevented by calling\n      // `unref()` on the returned object.\n      ticker.unref()\n      // @ts-ignore\n    } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {\n      // similar like for NodeJS, but with the Deno API\n      // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n      // @ts-ignore\n      Deno.unrefTimer(ticker)\n    }\n\n    // run the tick immediately\n    await this._autoRefreshTokenTick()\n  }\n\n  /**\n   * This is the private implementation of {@link #stopAutoRefresh}. Use this\n   * within the library.\n   */\n  private async _stopAutoRefresh() {\n    const ticker = this.autoRefreshTicker\n    this.autoRefreshTicker = null\n\n    if (ticker) {\n      clearInterval(ticker)\n    }\n  }\n\n  /**\n   * Starts an auto-refresh process in the background. The session is checked\n   * every few seconds. Close to the time of expiration a process is started to\n   * refresh the session. If refreshing fails it will be retried for as long as\n   * necessary.\n   *\n   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n   * to call this function, it will be called for you.\n   *\n   * On browsers the refresh process works only when the tab/window is in the\n   * foreground to conserve resources as well as prevent race conditions and\n   * flooding auth with requests. If you call this method any managed\n   * visibility change callback will be removed and you must manage visibility\n   * changes on your own.\n   *\n   * On non-browser platforms the refresh process works *continuously* in the\n   * background, which may not be desirable. You should hook into your\n   * platform's foreground indication mechanism and call these methods\n   * appropriately to conserve resources.\n   *\n   * {@see #stopAutoRefresh}\n   */\n  async startAutoRefresh() {\n    this._removeVisibilityChangedCallback()\n    await this._startAutoRefresh()\n  }\n\n  /**\n   * Stops an active auto refresh process running in the background (if any).\n   *\n   * If you call this method any managed visibility change callback will be\n   * removed and you must manage visibility changes on your own.\n   *\n   * See {@link #startAutoRefresh} for more details.\n   */\n  async stopAutoRefresh() {\n    this._removeVisibilityChangedCallback()\n    await this._stopAutoRefresh()\n  }\n\n  /**\n   * Runs the auto refresh token tick.\n   */\n  private async _autoRefreshTokenTick() {\n    const now = Date.now()\n\n    try {\n      const {\n        data: { session },\n      } = await this.getSession()\n\n      if (!session || !session.refresh_token || !session.expires_at) {\n        return\n      }\n\n      // session will expire in this many ticks (or has already expired if <= 0)\n      const expiresInTicks = Math.floor(\n        (session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION\n      )\n\n      if (expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD) {\n        await this._callRefreshToken(session.refresh_token)\n      }\n    } catch (e: any) {\n      console.error('Auto refresh tick failed with error. This is likely a transient error.', e)\n    }\n  }\n\n  /**\n   * Registers callbacks on the browser / platform, which in-turn run\n   * algorithms when the browser window/tab are in foreground. On non-browser\n   * platforms it assumes always foreground.\n   */\n  private async _handleVisibilityChange() {\n    if (!isBrowser() || !window?.addEventListener) {\n      if (this.autoRefreshToken) {\n        // in non-browser environments the refresh token ticker runs always\n        this.startAutoRefresh()\n      }\n\n      return false\n    }\n\n    try {\n      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false)\n\n      window?.addEventListener('visibilitychange', this.visibilityChangedCallback)\n\n      // now immediately call the visbility changed callback to setup with the\n      // current visbility state\n      await this._onVisibilityChanged(true) // initial call\n    } catch (error) {\n      console.error('_handleVisibilityChange', error)\n    }\n  }\n\n  /**\n   * Callback registered with `window.addEventListener('visibilitychange')`.\n   */\n  private async _onVisibilityChanged(isInitial: boolean) {\n    if (document.visibilityState === 'visible') {\n      if (!isInitial) {\n        // initial visibility change setup is handled in another flow under #initialize()\n        await this.initializePromise\n        await this._recoverAndRefresh()\n      }\n\n      if (this.autoRefreshToken) {\n        // in browser environments the refresh token ticker runs only on focused tabs\n        // which prevents race conditions\n        this._startAutoRefresh()\n      }\n    } else if (document.visibilityState === 'hidden') {\n      if (this.autoRefreshToken) {\n        this._stopAutoRefresh()\n      }\n    }\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n   */\n  private async _getUrlForProvider(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    if (this.flowType === 'pkce') {\n      const codeVerifier = generatePKCEVerifier()\n      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n      const codeChallenge = await generatePKCEChallenge(codeVerifier)\n      const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n      const flowParams = new URLSearchParams({\n        code_challenge: `${encodeURIComponent(codeChallenge)}`,\n        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`,\n      })\n      urlParams.push(flowParams.toString())\n    }\n    if (options?.queryParams) {\n      const query = new URLSearchParams(options.queryParams)\n      urlParams.push(query.toString())\n    }\n\n    return `${this.url}/authorize?${urlParams.join('&')}`\n  }\n\n  private async _unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      return await _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n        headers: this.headers,\n        jwt: sessionData?.session?.access_token,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#enroll}\n   */\n  private async _enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/factors`, {\n        body: {\n          friendly_name: params.friendlyName,\n          factor_type: params.factorType,\n          issuer: params.issuer,\n        },\n        headers: this.headers,\n        jwt: sessionData?.session?.access_token,\n      })\n\n      if (error) {\n        return { data: null, error }\n      }\n\n      if (data?.totp?.qr_code) {\n        data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`\n      }\n\n      return { data, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#verify}\n   */\n  private async _verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      const { data, error } = await _request(\n        this.fetch,\n        'POST',\n        `${this.url}/factors/${params.factorId}/verify`,\n        {\n          body: { code: params.code, challenge_id: params.challengeId },\n          headers: this.headers,\n          jwt: sessionData?.session?.access_token,\n        }\n      )\n      if (error) {\n        return { data: null, error }\n      }\n\n      await this._saveSession({\n        expires_at: Math.round(Date.now() / 1000) + data.expires_in,\n        ...data,\n      })\n      await this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data)\n\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#challenge}\n   */\n  private async _challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      return await _request(\n        this.fetch,\n        'POST',\n        `${this.url}/factors/${params.factorId}/challenge`,\n        {\n          headers: this.headers,\n          jwt: sessionData?.session?.access_token,\n        }\n      )\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#challengeAndVerify}\n   */\n  private async _challengeAndVerify(\n    params: MFAChallengeAndVerifyParams\n  ): Promise<AuthMFAVerifyResponse> {\n    const { data: challengeData, error: challengeError } = await this._challenge({\n      factorId: params.factorId,\n    })\n    if (challengeError) {\n      return { data: null, error: challengeError }\n    }\n    return await this._verify({\n      factorId: params.factorId,\n      challengeId: challengeData.id,\n      code: params.code,\n    })\n  }\n\n  /**\n   * {@see GoTrueMFAApi#listFactors}\n   */\n  private async _listFactors(): Promise<AuthMFAListFactorsResponse> {\n    const {\n      data: { user },\n      error: userError,\n    } = await this.getUser()\n    if (userError) {\n      return { data: null, error: userError }\n    }\n\n    const factors = user?.factors || []\n    const totp = factors.filter(\n      (factor) => factor.factor_type === 'totp' && factor.status === 'verified'\n    )\n\n    return {\n      data: {\n        all: factors,\n        totp,\n      },\n      error: null,\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n   */\n  private async _getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse> {\n    const {\n      data: { session },\n      error: sessionError,\n    } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n    if (!session) {\n      return {\n        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n        error: null,\n      }\n    }\n\n    const payload = this._decodeJWT(session.access_token)\n\n    let currentLevel: AuthenticatorAssuranceLevels | null = null\n\n    if (payload.aal) {\n      currentLevel = payload.aal\n    }\n\n    let nextLevel: AuthenticatorAssuranceLevels | null = currentLevel\n\n    const verifiedFactors =\n      session.user.factors?.filter((factor: Factor) => factor.status === 'verified') ?? []\n\n    if (verifiedFactors.length > 0) {\n      nextLevel = 'aal2'\n    }\n\n    const currentAuthenticationMethods = payload.amr || []\n\n    return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}